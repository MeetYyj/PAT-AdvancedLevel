1.逻辑，注意：数的范围，0，logN/logM，实现：循环或者if实现
2.逻辑，内容：多项式相加，注意：多项式系数和为0的情况，实现：两个索引，进行值比较
3.图，dijkstra算法，内容：最短路径，注意：1.由于要统计最短路径条数，需要开一个数组来存（当到达某个点的路径长度相等且都等于最短路径时的）路径条数2.由于要统计救援队个数，这里是统计所有最短路径里的其中能聚集到最多救援队的路径的队数，所以要开一个数组记录
4.用vector<int> v[100]来存类似于树的结构，bfs，dfs，内容：统计每层中无子叶的节点数，注意：要记录下树的层数，记录无子叶的节点数
5.字符串，内容：字符求和，注意：用数组来存要输出的有顺序的字符比较酷，考虑0
6.输入输出，数据处理，sort，内容：比较HH:MM:SS时间，注意：用HH*3600+MM*60+SS来比较写sort的比较函数会比较简单
7.下标规划题，内容：查找一串数中最大的子数列，注意：因为数列中可能有0，所以sum一开始要置-1，以及立flg来检测是否全为负数
8.逻辑，内容：做电梯的时间（太简单忽略好了）
9.逻辑，内容：多项式相乘，注意：多项式系数为0的情况，相乘时的最大系数可能为单个多项式输入系数的两倍
10.进制转换，二分法，数据范围，内容：进制转换，注意：确定进制上下界，用二分法来寻找使得数据相等的进制，在寻找的过程中，当数据2计算过程中的值超过数据1的值的时候应该break剪枝，测试点10好像是个坑，加上注释掉区包围的代码才算对，但感觉判定有问题，如果测试用例是1 1 1 10，答案输出应该是2才对吧，加上岂不是10了...不知道是什么奇怪的原因
11.逻辑，内容：找最大输出，注意：用数组实现字符串的选择输出比较酷，这道题的答案和样例的输出不一样却是对的，我也是醉了，我还强行试着四舍五入一下，没事不要作
12.排序，内容：输出一个学生的名次最高的科目（有许多学科和学生），注意：多多个科目使用sort函数，可以用一个flg，来改变数组下标，以此来改变排序所依据的数据，成绩一样并列名次的处理，可以让该学生的名次等于上一个学生的名次，一旦不同，还是用循环的下标确定名次。
13.图，bfs/dfs，图的连通分量的统计，内容：图的一个节点被拆除后剩余多少连通分量，注意：在遍历的最大for循环里，对没访问的节点加个统计值cnt就可以了
14.queue，逻辑，内容：银行排队，注意：只要在17:00前开始办理业务的就能办理完（坑），处理好队列中元素是不是达到capacity的情况，先遍历队列的元素个数，找最小值，如果最小值为capacity，就pop出所有队列中第一个元素最小的值，并把其他的队列值的以一个元素减去该值，在把接受到的顾客push进刚刚pop出的那个队列。
15.素数，进制转换，内容：求一个数在某进制下的逆序数字再转换为10进制是否是素数，注意：0,1不是素数，2是素数，可以用i*i<n来代替i<sqrt(n)。
16.排序，处理输入输出，时间转换，内容：输出不同时段的电话费不同，一群人打了一万个电话，让算钱，注意：这道题大坑啊，其中包括一个如果都是无效输入的话就不打印他的信息。
17.排序，逻辑，内容：又是银行排队，注意：处理好提早到的(用８点减去他们到的时间)，17:00以后到的，直接在循环开始的时候判断然后continue，然后需要一个时间戳，在每个顾客进来的时候与时间戳比较决定是否更新时间戳或者增加waitingtime的综合，或者在队伍全不为0的时候更新(推出processing time里时间最短的那个，并把其他顾客的时间减去该时间，更新时间戳+=processing time)，更新最小的那个时间为当前顾客所需处理时间，如果含0，直接更新为当前顾客所需时间。
18.图，dijkstra，dfs，内容：自行车容量调节，注意：首先用dijkstra算法求最短路径(可能有多条，所以存路径的path数组本身也是个数组，可以用vector<int> path[501]实现)，然后对最短路径进行dfs，并用vector<int>tmppath存路径，每次递归到原点的时候于最少需要携带的自行车和最少需要带回的自行车比较并决定是否更新path。
19.进制，回文，内容：判断一个数是否是在某进制下的回文数字，注意：0
20.树的遍历，bfs，内容：已知树的后序和中序输出建树，然后再层序输出，注意：递归时候的范围。
21.树，bfs/dfs，树的层数，连通分量，内容：判断一个图是不是树，注意：要把每个根节点作为起始节点算一遍，可以判断有多少个连通分量，同时也要记录下每个节点的层数和树的总层数。
22.输入输出，字符串，map<string, set<int>>，内容：处理图书输入和检索，注意：学一下map先= =
23.大数处理，内容：一个数字乘2后的每个数字的个数是否与之前相同，注意：20位及以上的数字就要用char来处理了，long long并不行
24.大数相加，内容：不断讲输入数与输入数的逆序相加并判断是不是回文数，注意：可以用string存,然后用reverse(s.bebgin(), s.end())得到反向的字符串，就可以直接用string的相等运算符比较了，字符串数的相加要熟练，麻痹，我又制造了一堆垃圾代码
25.排序，内容：对各个考场的学生的成绩进行按考场排序和总排序，然后输出
26.排队
27.进制转换，内容：13进制转换
28.排序，内容：按照某个信息排序，注意：不要用cout输出，不然会超时
29.排序，内容：对两个数列排序，注意：不知道为什么long不行改成int就可以了。
30.
31.输入输出
32.链表，内容：输出两个单词中相同字符串开头字符的地址，注意：链表用结构体数组实现，链表遍历用for(int i = startaddr; i != -1; i = nodes[i].next)实现。
33.贪心算法，内容：加油站问题，如何使得话费最少，注意：如果一开始的加油站的位置大于0，则输出最远距离0.00，case3。算法实现：在当前加油站看距离内的所有加油站，如果有比当前加油站收费低的，就加油加到能够到达该处为止，如果没有，则看看有没有终点，有终点，则加满到终点的油量，没有则加满油，然后开到剩下的加油站中价格最低的地方再重新判断。如果当前距离内没有加油站，则输出距离位当前加油站位置再加上满油最大行驶距离。但是我把终点也当成一个油价为0的加油站做貌似挺好，还有就是找不到更低的加油站就加满油开到下一个，麻烦的是如果下一个能找到更低的就要判断下当前的油能不能开到该加油站，如果能就直接减，不能的话还得加点油。
34.图的遍历，map，内容：通过通话时长，找各个帮派的头目，注意：用图的连通分量数来计算帮派的个数，每个连通分量的节点数是每个帮派的人员数，然后还要统计通话时长，即边的权值，访问过的边可以置0避免重复访问。用map处理输入会比较简单。
35.字符串输入输出，内容：易错字修改
36.排序，内容：男女成绩分开排序
37.排序，贪心？，内容：正的和正的乘一下，负的和负的乘一下就通过的吓哭
38.贪心？，内容：给一堆数字，组合出最小数字，注意：妈的博主好强，cmp函数比较可以用return a+b < b+a;是0可以用if(s[0] == '0'){strv.erase(s.begin())}，坑是如果全是0，则应该输出0
39.哈希函数，内容：输出对应名字学生所选的课程，注意：如果用map<string, vector<int>>实现的话最后一组数据会超时
40.字符串统计，内容：找到最长的回文子字符串，注意：要考虑单数双数两种情况
41.数据处理，内容：输出一堆数字中最早的只出现一次的数字，注意：可以用map感觉
42.数据处理，内容：不断地变换输入的数据的位置，注意：有序的输出可以用字符数组求余，S1 S2 ... S13 H1 H2 ... H13 C1 C2 ... C13 D1 D2 ... D13 J1 J2，构造char c[6] = {"SHCDJ"};　printf("%c%d", c[index/13], index%13 + 1);
43.二叉搜索树，bst，内容：判断一棵树是不是二叉搜索树或者是其镜像，注意：多多练习树的建立和树的前序后序输出啊，vector可以用==操作符。
44.逻辑，二分法，内容：输出一段数字中和大于等于给定值中最小的一个的子片段下标组，直接暴力解题会超时，要进行剪枝，或者存和再用二分法查找。
45.最长上升子序列，内容：最长颜色序列输出，注意：需要将顺序输入的颜色对应到上升的小标，在读入搜索数列时，应该进行转换并把不需要的颜色丢弃，然后用类似递归的思想从第一个数开始不断+1下标然后找该数的最小上升子序列。
46.数据处理，内容：已知一个由节点构成的环形，输出两个节点间的最短距离，注意：存的时候直接存sum，该节点到第一个节点的总距离，不然会超时，交换数据时用swap(a,b)更加快。
47.hash，vector，内容：输出一个学校的课程数，注意：好像不hash也可以过，fuck
48.数据处理，内容：给定一组数，和一个值m，求满足a+b=m的最小数对，注意：麻痹数组要初始化为0
49.数据处理，内容：给出一个数n，统计从1到n中总共出现的"1"的次数，注意：要写成int(a / pow(10, i+1)) * pow(10, i)形式
50.字符串检索，内容：给定一个字符串s1，再给要减去的字符们s2，输出s1被s2减去后的字符串，注意：为了防止超时，可以建立一个数组bool flg[512]什么的用来存该字符是否有效，在s2输入时吧flg的对应位置"false"，然后在输出s1的时候判断下flg就可以了
51.栈模拟，内容：有个容量上线为m的栈，依次吧1,2,3,...,n入栈，给出一个出栈顺序，问其是否能实现，注意：应该按照题意从1开始放数据，每放一个数据和出栈顺序的当前个比较，如果栈顶元素和出栈顺序前端元素相同，则pop，并把出栈顺序的下标加一，如果爆栈了要break，如果最后的index != n也是无法实现
52.链表，内容：把链表串一下，再按关键字增序重新组织链表，注意：如果链表为空，输出0 -1，可能有坏节点，应该先遍历一遍列表，可以在struct上加flg表示是不是好节点，也可以直接push到一个vector里

