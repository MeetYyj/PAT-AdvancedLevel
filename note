1.逻辑，注意：数的范围，0，logN/logM，实现：循环或者if实现
2.逻辑，内容：多项式相加，注意：多项式系数和为0的情况，实现：两个索引，进行值比较
3.图，dijkstra算法，内容：最短路径，注意：1.由于要统计最短路径条数，需要开一个数组来存（当到达某个点的路径长度相等且都等于最短路径时的）路径条数2.由于要统计救援队个数，这里是统计所有最短路径里的其中能聚集到最多救援队的路径的队数，所以要开一个数组记录
4.用vector<int> v[100]来存类似于树的结构，bfs，dfs，内容：统计每层中无子叶的节点数，注意：要记录下树的层数，记录无子叶的节点数
5.字符串，内容：字符求和，注意：用数组来存要输出的有顺序的字符比较酷，考虑0
6.输入输出，数据处理，sort，内容：比较HH:MM:SS时间，注意：用HH*3600+MM*60+SS来比较写sort的比较函数会比较简单
7.下标规划题，内容：查找一串数中最大的子数列，注意：因为数列中可能有0，所以sum一开始要置-1，以及立flg来检测是否全为负数
8.逻辑，内容：做电梯的时间（太简单忽略好了）
9.逻辑，内容：多项式相乘，注意：多项式系数为0的情况，相乘时的最大系数可能为单个多项式输入系数的两倍
10.进制转换，二分法，数据范围，内容：进制转换，注意：确定进制上下界，用二分法来寻找使得数据相等的进制，在寻找的过程中，当数据2计算过程中的值超过数据1的值的时候应该break剪枝，测试点10好像是个坑，加上注释掉区包围的代码才算对，但感觉判定有问题，如果测试用例是1 1 1 10，答案输出应该是2才对吧，加上岂不是10了...不知道是什么奇怪的原因
11.逻辑，内容：找最大输出，注意：用数组实现字符串的选择输出比较酷，这道题的答案和样例的输出不一样却是对的，我也是醉了，我还强行试着四舍五入一下，没事不要作
12.排序，内容：输出一个学生的名次最高的科目（有许多学科和学生），注意：多多个科目使用sort函数，可以用一个flg，来改变数组下标，以此来改变排序所依据的数据，成绩一样并列名次的处理，可以让该学生的名次等于上一个学生的名次，一旦不同，还是用循环的下标确定名次。
13.图，bfs/dfs，图的连通分量的统计，内容：图的一个节点被拆除后剩余多少连通分量，注意：在遍历的最大for循环里，对没访问的节点加个统计值cnt就可以了
14.queue，逻辑，内容：银行排队，注意：只要在17:00前开始办理业务的就能办理完（坑），处理好队列中元素是不是达到capacity的情况，先遍历队列的元素个数，找最小值，如果最小值为capacity，就pop出所有队列中第一个元素最小的值，并把其他的队列值的以一个元素减去该值，在把接受到的顾客push进刚刚pop出的那个队列。
15.素数，进制转换，内容：求一个数在某进制下的逆序数字再转换为10进制是否是素数，注意：0,1不是素数，2是素数，可以用i*i<n来代替i<sqrt(n)。
16.排序，处理输入输出，时间转换，内容：输出不同时段的电话费不同，一群人打了一万个电话，让算钱，注意：这道题大坑啊，其中包括一个如果都是无效输入的话就不打印他的信息。
17.排序，逻辑，内容：又是银行排队，注意：处理好提早到的(用８点减去他们到的时间)，17:00以后到的，直接在循环开始的时候判断然后continue，然后需要一个时间戳，在每个顾客进来的时候与时间戳比较决定是否更新时间戳或者增加waitingtime的综合，或者在队伍全不为0的时候更新(推出processing time里时间最短的那个，并把其他顾客的时间减去该时间，更新时间戳+=processing time)，更新最小的那个时间为当前顾客所需处理时间，如果含0，直接更新为当前顾客所需时间。
18.图，dijkstra，dfs，内容：自行车容量调节，注意：首先用dijkstra算法求最短路径(可能有多条，所以存路径的path数组本身也是个数组，可以用vector<int> path[501]实现)，然后对最短路径进行dfs，并用vector<int>tmppath存路径，每次递归到原点的时候于最少需要携带的自行车和最少需要带回的自行车比较并决定是否更新path。
19.进制，回文，内容：判断一个数是否是在某进制下的回文数字，注意：0
20.树的遍历，bfs，内容：已知树的后序和中序输出建树，然后再层序输出，注意：递归时候的范围。
21.树，bfs/dfs，树的层数，连通分量，内容：判断一个图是不是树，注意：要把每个根节点作为起始节点算一遍，可以判断有多少个连通分量，同时也要记录下每个节点的层数和树的总层数。
22.输入输出，字符串，map<string, set<int>>，内容：处理图书输入和检索，注意：学一下map先= =
23.大数处理，内容：一个数字乘2后的每个数字的个数是否与之前相同，注意：20位及以上的数字就要用char来处理了，long long并不行
24.大数相加，内容：不断讲输入数与输入数的逆序相加并判断是不是回文数，注意：可以用string存,然后用reverse(s.bebgin(), s.end())得到反向的字符串，就可以直接用string的相等运算符比较了，字符串数的相加要熟练，麻痹，我又制造了一堆垃圾代码
25.排序，内容：对各个考场的学生的成绩进行按考场排序和总排序，然后输出
26.排队
27.进制转换，内容：13进制转换
28.排序，内容：按照某个信息排序，注意：不要用cout输出，不然会超时
29.排序，内容：对两个数列排序，注意：不知道为什么long不行改成int就可以了。
30.dijkstra，dfs，内容：找一个图中的最短路径，如果长度一样找花费最少。
31.输入输出
32.链表，内容：输出两个单词中相同字符串开头字符的地址，注意：链表用结构体数组实现，链表遍历用for(int i = startaddr; i != -1; i = nodes[i].next)实现。
33.贪心算法，内容：加油站问题，如何使得话费最少，注意：如果一开始的加油站的位置大于0，则输出最远距离0.00，case3。算法实现：在当前加油站看距离内的所有加油站，如果有比当前加油站收费低的，就加油加到能够到达该处为止，如果没有，则看看有没有终点，有终点，则加满到终点的油量，没有则加满油，然后开到剩下的加油站中价格最低的地方再重新判断。如果当前距离内没有加油站，则输出距离位当前加油站位置再加上满油最大行驶距离。但是我把终点也当成一个油价为0的加油站做貌似挺好，还有就是找不到更低的加油站就加满油开到下一个，麻烦的是如果下一个能找到更低的就要判断下当前的油能不能开到该加油站，如果能就直接减，不能的话还得加点油。
34.图的遍历，map，内容：通过通话时长，找各个帮派的头目，注意：用图的连通分量数来计算帮派的个数，每个连通分量的节点数是每个帮派的人员数，然后还要统计通话时长，即边的权值，访问过的边可以置0避免重复访问。用map处理输入会比较简单。
35.字符串输入输出，内容：易错字修改
36.排序，内容：男女成绩分开排序
37.排序，贪心？，内容：正的和正的乘一下，负的和负的乘一下就通过的吓哭
38.贪心？，内容：给一堆数字，组合出最小数字，注意：妈的博主好强，cmp函数比较可以用return a+b < b+a;是0可以用if(s[0] == '0'){strv.erase(s.begin())}，坑是如果全是0，则应该输出0
39.哈希函数，内容：输出对应名字学生所选的课程，注意：如果用map<string, vector<int>>实现的话最后一组数据会超时
40.字符串统计，内容：找到最长的回文子字符串，注意：要考虑单数双数两种情况
41.数据处理，内容：输出一堆数字中最早的只出现一次的数字，注意：可以用map感觉
42.数据处理，内容：不断地变换输入的数据的位置，注意：有序的输出可以用字符数组求余，S1 S2 ... S13 H1 H2 ... H13 C1 C2 ... C13 D1 D2 ... D13 J1 J2，构造char c[6] = {"SHCDJ"};　printf("%c%d", c[index/13], index%13 + 1);
43.二叉搜索树，bst，内容：判断一棵树是不是二叉搜索树或者是其镜像，注意：多多练习树的建立和树的前序后序输出啊，vector可以用==操作符。
44.逻辑，二分法，内容：输出一段数字中和大于等于给定值中最小的一个的子片段下标组，直接暴力解题会超时，要进行剪枝，或者存和再用二分法查找。
45.最长上升子序列，内容：最长颜色序列输出，注意：需要将顺序输入的颜色对应到上升的小标，在读入搜索数列时，应该进行转换并把不需要的颜色丢弃，然后用类似递归的思想从第一个数开始不断+1下标然后找该数的最小上升子序列。
46.数据处理，内容：已知一个由节点构成的环形，输出两个节点间的最短距离，注意：存的时候直接存sum，该节点到第一个节点的总距离，不然会超时，交换数据时用swap(a,b)更加快。
47.hash，vector，内容：输出一个学校的课程数，注意：好像不hash也可以过，fuck
48.数据处理，内容：给定一组数，和一个值m，求满足a+b=m的最小数对，注意：麻痹数组要初始化为0
49.数据处理，内容：给出一个数n，统计从1到n中总共出现的"1"的次数，注意：要写成int(a / pow(10, i+1)) * pow(10, i)形式
50.字符串检索，内容：给定一个字符串s1，再给要减去的字符们s2，输出s1被s2减去后的字符串，注意：为了防止超时，可以建立一个数组bool flg[512]什么的用来存该字符是否有效，在s2输入时吧flg的对应位置"false"，然后在输出s1的时候判断下flg就可以了
51.栈模拟，内容：有个容量上线为m的栈，依次吧1,2,3,...,n入栈，给出一个出栈顺序，问其是否能实现，注意：应该按照题意从1开始放数据，每放一个数据和出栈顺序的当前个比较，如果栈顶元素和出栈顺序前端元素相同，则pop，并把出栈顺序的下标加一，如果爆栈了要break，如果最后的index != n也是无法实现
52.链表，内容：把链表串一下，再按关键字增序重新组织链表，注意：如果链表为空，输出0 -1，可能有坏节点，应该先遍历一遍列表，可以在struct上加flg表示是不是好节点，也可以直接push到一个vector里
53.树，dfs，内容：给一棵树的结构和权值，找从根结点到叶子结点的路径上的权值相加之和等于给定目标数的路径，并且从大到小输出路径，注意：判断是否等于目标数的时候还要判断下是不是没有叶节点（就是是不是到了底部），sort应该在一开始就根据子节点的权值sort的
54.map，内容：选取主色调，就是M列N行的矩阵里面出现次数多余一半的那个数字，注意：没什么好注意的。
55.vector，排序，剪枝优化，内容：给出n个人的姓名，年龄和拥有的钱，进行k次查询，每次查询输出在年龄区间内的财富值的从大到小的前m个人的信息。如果财富值相同就就先输出年龄小的，如果年龄相同就把名字按照字典序排序输出，注意：由于每次的排名输出最多只需要输出100个人，但是总过有100000个人，年龄有200种，所以每个年龄下有500个人，如果直接暴力解题会超时，应该先对所有人排序，再删去每个年龄段100名以后的人，最后再根据查询要求输出
56.模拟，逻辑，队列，内容：np为老鼠的数量，ng为每组最多g个老鼠。先给出np个老鼠的重量，再给出老鼠的初始顺序（第i名的老鼠是第j号，j从0开始）。每ng个老鼠分为一组，对于每组老鼠，选出最重的那个，晋级下一轮比赛，然后依次再以np个老鼠一组分类，然后选出重量最大的。直到只剩下一只老鼠，排名为1.输出为老鼠的排名，这个排名是按照原输入老鼠的顺序输出的。注意：vector的拷贝v2 = {v1.cbegin(), v1.cend()}，可以先把编号都推到队列q里，记录队列长度qsize = q.size()，它们的名次为qsize()/ng+1，然后开始模拟分组找最重的老鼠for实现，并把最重的老鼠推到队列末尾，计数值达到原队列q长度qsize的时候一轮模拟结束，重新进行第二轮模拟，直到队列长度为1的时候把那只老鼠名次设置为1并break。
57.树状数组，二分法，内容：现请你实现一种特殊的堆栈，它多了一种操作叫“查中值”，即返回堆栈中所有元素的中值。对于N个元素，若N是偶数，则中值定义为第N/2个最小元；若N是奇数，则中值定义为第(N+1)/2个最小元。注意：要用树状数组，树状数组主要有3个函数，int lowbit(i)，void update(i)，int getsum(i)，考前需要复习下，这里的二分法要最早出现的与检索关键值k相等的下标，所以判定条件是if(getsum(mid) >= k) right = mid; else left = mid + 1; return left;。
58.进制，进位，内容：霍格沃兹钱的计算，注意：加上进位
59.分解质因数，map(其实可以不用)，内容：分解质因数，注意：其实不用判断是不是素数，应为不可能分解出和数，map的遍历用auto map_it = map1.cbegin();
60.科学计数法，字符串处理，内容：给两个浮点数，问它们转换成n位有效位的科学计数法后是否相等，注意：坑太多，先读入字符串，然后写个处理函数，在函数里转化为要输出的数，00.0000，0.001000，00100这种东西都要出书，10^0也要输出。
61.字符串处理，内容：福尔摩斯的约会时间，根据相同的字符求得约会时间，注意：判断的字母范围防止数组越界。比如周一到周日应该对应的时字母'A'到'G'。
62.排序，内容：德才论
63.set，内容：给定两个整数集合，它们的相似度定义为：Nc/Nt*100%。其中Nc是两个集合都有的不相等整数的个数，Nt是两个集合一共有的不相等整数的个数。你的任务就是计算任意一对给定集合的相似度。Nc是两个集合的公共元素个数，Nt是两个集合的所有包含的元素个数（其中元素个数表示各个元素之间互不相同）。注意：求两个集合的并集会超时(不管是用set_union(s1.cbegin(), s1.cend(), s2.cbegin(), s2.cend(), inserter(sunion, sunion.begin()));还是直接sunion.insert(s1.cbegin(), s1.cend()); sunion.insert(s2.cbegin(), s2.cend()); 但是用求两个集合的并集却不会超时set_intersection(*****);当然也可以手动遍历s1，s2来找相同元素的个数，遍历s1，调用s2.find(s1value);函数
64.BST，内容：给一组数字，要求建出完全二叉搜索树，注意：把原始数据排序后其实就是二叉搜索树的中序输出，然后只要找到根节点然后左右递归找左右子树的根节点就可以了，程序上的事先可以用递归函数实现(需要传3个参数，start，end，index(index用来保存要输出的数字的次序))，也可以用队列实现，相当于bfs。
65.数据处理，存储的溢出，内容：比较a+b>c?注意：计算过程中可能会溢出，要分开讨论，千万别做成字符串处理题...
66.AVL树的建立，二叉搜索树，内容：找到AVL树的根，注意：熟悉AVL树的建立，和它的4种旋转方式L，LR，R，RL
67.连通量，内容：swap(0, *)，给定一序列数，然后只能用0交换进行排序，注意：个人的思路是设定一个标记位，把位置正确的先排除，然后从位置0开始遍历没有被标记的，遍历完所有的连通分量，然后要注意的时含0的连通分量要-1，不含0的要加一。
68.动态规划，背包问题，内容：用n个硬币买价值为m的东西，输出使用方案，使得正好几个硬币加起来价值为m。从小到大排列，输出最小的那个排列方案，注意：先对硬币降序排序，开一个dp[100001][101]的数组用来存放第i个硬币处能否凑成j元(不一定要刚好凑成)，用book[100001][101]数组来标记是否可以用第i个硬币来更新j元，最后从后往前输出
69.数据处理，内容：数字黑洞
70.vector，sort，内容：月饼
71.map，字符处理，内容：统计出现最多次数的单词，注意："can can"\n 和 "can can\n 他们can的统计次数应该都为2次，要注意判断循环退出时的字符串是否为空。
72.Dijkstra，字符数字转换，内容：从m个加油站里面选取1个站点，让他离居民区的最近的人最远，并且没有超出服务范围ds之内。如果有很多个最远的加油站，输出距离所有居民区距离平均值最小的那个。如果平均值还是一样，就输出按照顺序排列加油站编号最小的那个，注意：如果用Floyd算法最后一个测试点会超时，还是对最多10个加油站都进行一次Dijkstra算法比较快。
73.字符串处理，科学计数法，内容：把科学计数法转化为正常数字，注意：分类讨论1.指数为正且大于精度，2.指数为正小于精度，3.指数为0,4.指数为负
74.链表，内容：反转部分链表，注意：不一定所有节点都在链表上，需要先遍历一遍
75.map，数据处理，排序，内容：pat的计分系统，注意：对于已经满分的题目再次提交不能增加通过满分题目的数量，可以通过判断当前分数是否是满分来获得，还有就是一旦有人有编译通过的情况就要把他加入到有效人员里。
76.bfs，内容：给出每个用户关注的人的id，和转发最多的层数，求一个id发了条微博最多会有多少个人转发，注意：不能用DFS，因为在第一次这个人被标记的时候不一定时最小层数的关系网，如果不标记只用层数来返回会超时?所以用bfs需要用一个layer[num]数组来记录各个节点的层数
77.字符串，内容：给定N给字符串，求他们的公共后缀，如果不存在公共后缀，就输出"nai"，注意：下标不要越界，可以在存完一串string后反过来，读入以\n结尾的string可以用getline(cin,str)
78.hash，平方探测法，内容：给出散列表长和要插入的元素，将这些元素按照读入的顺序插入散列表中，其中散列函数为h(key) = key % TSize，解决冲突采用只向正向增加的二次方探查法。如果题中给出的TSize不是素数，就取第一个比TSize大的素数作为TSize，注意：要用只往正方向走的平方探测法，平方的循环最大值为TSize
79.树，dfs，内容：给一棵树，在树根出货物的价格为p，然后从根结点开始每往下走一层，该层的货物价格将会在父亲结点的价格上增加r%，给出每个叶结点的货物量，求他们的价格之和，注意：要判断是不是走到了叶节点上，是叶节点就计算sum。
80.排序，内容：模拟100个学校招收40000个学生，每个学生有5个志愿，每个学校最多能招n1，n2，n3...个人，招收原则，学生按先总成绩，再笔试成绩，排名，如果学生名次一样，即使学校招收名额已经满了也要把所有名次一样的学生招收进来，注意：要有一个lastran[101]数组来存每个学校目前招收的最后一个学生的名次
81.分数相加，内容：分数相加，注意：辗转相除法求公约数，最小公倍数就是a*b/公约数，注意分子为零的时候化简分数应该直接化简为0/1不要用辗转相除，不然会浮点错误
82.字符串处理，内容：用中文拼音方式读写数字，注意：连续的0可以用一个0代替，用#标记掉没有用的0，如果0是个位或者是万位就不输出，其他就输出0，如果全世界只有一个0就输出ling
83.sort，内容：题目大意：给出n个考生的信息，按照分数从高到低排序，并且输出给定区间的考生信息。如果不存在满足条件的考生就输出NONE，注意：没什么好注意的
84.字符串，内容：坏键盘，给两个字符串，输出没有输出的字符，注意：应该先把不同的字符都存起来，然后开一个bool printed[10+26+1]的数组，输出过的字符就把该位设置为true，然后为true就不输出，其实开bool printed[256]应该更加方便
85.二分法，也可以用剪枝，内容：给定一个序列，找到满足M <= m*p的最长子数列长度，M是子数列中的最大值，m是子数列中的最小值，p是题目给定的倍数，注意：可以用二分搜索剪枝，也可以用每次查找的时候从加上当前最大长度的数字处开始判断进行剪枝，二分法注意判断条件是left<right，返回值是left
86.树，前序中序转后序，内容：用栈的形式给出一棵二叉树的建立的顺序，求这棵二叉树的后序遍历，注意：当递归的左下标和右下标相等的时候return，每次传三个参数，中序的left，right和前序的root
87.图，dijkstra，dfs，map，内容：条条大路通罗马，注意：注意点太多，感觉就是传说中的综合题
88.有理数四则运算，字符串，内容：有理数四则运算，注意：long
89.插入，并归，内容：给一个初始序列和一个中间序列，判断这个中间序列时由插入排序实现的还是由并归排序实现的，注意：插入排序的操作从下标1开始
90.树，dfs，N，内容：零售商的价格计算，供受关系由一组数据给出，求最大层数和，能达到最大层数的路径数，注意：最大层数的路径数和层数放在for循环之外更新比较好
91.bfs，内容：给定一个三维数组，0表示正常1表示有肿瘤，肿瘤块的大小大于等于t才算作是肿瘤，让计算所有满足肿瘤块的大小，注意：三维的广度优先搜索，注意边界，要使用方向向量x[6]，y[6]，z[6]
92.字符串，内容：买珠子
93.数学，内容：统计PAT
94.树，bfs，内容：统计家族树中人数最多的一辈，输出是第几辈，输出人数
95.排序，map，二分法，内容：停车场排序，求得停车时间最长的车辆，和每个请求时间内的车辆数，注意：用两个vector来记录车辆进入的时间invector和出去的时间outvector，然后查询的时候就在invector里找<=查询时间的车辆数减去outvector里<=查询时间的车辆数就可以了
96.数学，内容：一个正整数N的因子中可能存在若干连续的数字。例如630可以分解为3*5*6*7，其中5、6、7就是3个连续的数字。给定任一正整数N，要求编写程序求出最长连续因子的个数，并输出最小的连续因子序列。注意：从sqrt(630)开始往下遍历，看26，25，24...1到分别能够输出多长的数字序列，然后输出最大的那个
97.链表，内容：给一个链表，去重（去掉值或者绝对值相等的），先输出删除后的链表，再输出删除了的链表。注意：把不删除得了链表和需要输出的链表都分别存在resvector里和rmovevector里然后输出就好了
98.堆排序，内容：给出n和n个数的序列a和b，a为原始序列，b为排序其中的一个步骤，问b是a经过了堆排序还是插入排序的，并且输出它的下一步，注意：堆排序percdown传参数的时候要传堆顶元素下标和堆的长度。
99.树，中序遍历，层序遍历，内容：给出一棵二叉搜索树（给出每个结点的左右孩子），且已知根结点为0，求并且给出应该插入这个二叉搜索树的数值，求这棵二叉树的层序遍历，注意：先把data排序，然后中序遍历二叉搜索树，把data填进去，然后在层序遍历
100.字符串处理，内容：火星数字(13进制)和地球数字的互相转换，注意：用getline(cin,s)来读取包含空格的字符串，之前如果有cin要getchar一下
101.快速排序的前处理，内容：给一列数字，如果某个数字的左边数字都比它小，且右边的数字都比它大，则输出这个数字，注意：先正向遍历，存最大值，如果某个数比最大值大，则issmaller[index]=true(即它左边的都比它小)，更新最大值，再反向遍历，如果某个数比最小值小，则isbigger[index]=true(即它右边的值都比它大)，更新最小值，然后把两个都为true的输出。
102.树，中序，层序，内容：反转一棵二叉树，给出原二叉树的每个结点的左右孩子，输出它的层序和前序遍历，注意：根节点是所有子节点中没有出现的那个节点
103.递归算法，非典型dfs，内容：把数字n分解成k个数字的p次方，比如给169，5，2，169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2，输出可能解中因子和最大的那个，然后字典序最大的那个，注意：dfs(tmpn, tmpk, maxofi)传三个参数分别时当前的分解和，剩下的因子个数，和因子的最大值。
104.数学题，内容：给定一个序列，输出所有连续子序列的所有数的和，注意：double的强制类型转换
105.螺旋矩阵，内容：把数列排序后卷成螺旋，注意：用left，right，up，down来标记，可以这样初始化数组居然int a[m][n]，如果是vector则vector<vector<int>> v(m,vector<int>(n));
106.树，dfs，内容：卖东西，注意：
107.图，连通分量，dfs，内容：有n个人，每个人喜欢k个活动，如果两个人有任意一个活动相同，就称为他们处于同一个社交网络。求这n个人一共形成了多少个社交网络，并求每个社交网络的人数，注意：并查集? dfs的时候注意更新连通分量内的人数，还有标记收集。
108.字符串处理，内容：筛选出符合要求的字符串，注意：把原字符串存到char a[100]中，处理后的存在char b[100]中，调用double tmpd; sscanf(a, "%lf", &tmpd); sprintf(b,".2lf", tmpd);然后比较a的每一位(strlen(a))和b是不是相等就可以得到合理的字符串
109.逻辑，内容：排队拍照，注意：...
110.树，bfs，内容：给出一个n表示有n个结点，这n个结点为0~n-1，给出这n个结点的左右孩子，求问这棵树是不是完全二叉树，注意：先找没有出现的数字就是根节点，然后有一个计数cnt，队列q每次pop出一个节点就检查这个节点是不是-1(无节点)，如果时无效节点就检查当前的计数是不是和节点总数相同，相同就是完全二叉树，不相同就不是，如果不是-1就cnt++继续遍历
111.图，dijkstra，dfs，内容：给一个图，求路径中最短的一条，和用时最短的一条，注意：要用两遍dijkstra，dfs，注意dfs中push和pop的位置，路径比较可以在dfs中做也可以在出来后sort做。
112.字符串处理，内容：键盘某些键卡住了，按一次重复k次，要求找出可能的键，并且输出正确的字符串顺序。可能的键要求按照被发现的顺序输出。注意：一个键的后边num-1个键里只要有一个和本身不同，那么这个键就是好的，还有连续出现num个键不一定能说明这个是坏键，只有当它没有被标记为好键盘的时候才会是坏键
113.sort，内容：排序，注意：没什么好注意的
114.dfs，并查集?，内容：给定每个人的家庭成员和其自己名下的房产，请你统计出每个家庭的人口数、人均房产面积及房产套数。首先在第一行输出家庭个数（所有有亲属关系的人都属于同一个家庭）。随后按下列格式输出每个家庭的信息：家庭成员的最小编号 家庭人口数 人均房产套数 人均房产面积。其中人均值要求保留小数点后3位。家庭信息首先按人均面积降序输出，若有并列，则按成员编号的升序输出。注意：两条记录可能只通过孩子联系，或者只通过父母联系，要注意数据结构的构建方法。
115.bst，dfs，内容：输出一个二叉搜索树的最后两层结点个数a和b，以及他们的和c：“a + b = c”，注意：要用dfs统计每层下个数
116.数据处理，素数，内容：编程大赛奖品，是素数名次的发小黄人
117.逻辑，内容：爱丁顿数，注意：按照题意来比较简单，从小到达遍历，输出a[index]>index的最大的index
118.并查集，内容：一幅画里面的鸟为同一棵树上的，问有多少棵树和多少只鸟，以及对于两只鸟判断是否在同一个树上，注意：要用并查集做，并查集主要有两个操作int findparent(int a){...};和void union1(int a, int b){...};，实现过程中需要一个parent[maxx]数组来存自己的上一个节点是什么，如果自己的上一个节点是自己，则就是根，也可以通过判断parent[index] == index的个数来统计联通分量
119.树，前序后序转中序，内容：给出一棵树的结点个数n，以及它的前序遍历和后序遍历，输出它的中序遍历，如果中序遍历不唯一就输出No，且输出其中一个中序即可，如果中序遍历唯一就输出Yes，并输出它的中序，注意：是否唯一的条件就是所有非叶节点的节点都要有两个儿子
120.数据处理，内容：friend numbers，注意：没什么好注意的
121.数据处理，内容：单身狗，注意：没什么好注意的
122.图，内容：哈密顿回路？注意：感觉做了假题，1.判断输入个数不是顶点数+1，2.判断边是否存在，3.判断第一个顶点是不是和最后一个顶点一样
123.AVL树，中序遍历，判断满二叉树，内容：AVL树的建立，中序遍历和判断是不是满二叉树，注意：判断是不是满二叉树可以在中序遍历的时候队列每次push进去一个数cnt就++，如果cnt还不等于树的节点数num的时候出现了空子节点，则不是满二叉树，或者用如果出现了一个空的子节点，然后又出现了一个飞空节点，则不是满二叉树。

