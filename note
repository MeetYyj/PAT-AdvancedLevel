1.逻辑，注意：数的范围，0，logN/logM，实现：循环或者if实现
2.逻辑，内容：多项式相加，注意：多项式系数和为0的情况，实现：两个索引，进行值比较
3.图，dijkstra算法，内容：最短路径，注意：1.由于要统计最短路径条数，需要开一个数组来存（当到达某个点的路径长度相等且都等于最短路径时的）路径条数2.由于要统计救援队个数，这里是统计所有最短路径里的其中能聚集到最多救援队的路径的队数，所以要开一个数组记录
4.用vector<int> v[100]来存类似于树的结构，bfs，dfs，内容：统计每层中无子叶的节点数，注意：要记录下树的层数，记录无子叶的节点数
5.字符串，内容：字符求和，注意：用数组来存要输出的有顺序的字符比较酷，考虑0
6.输入输出，数据处理，sort，内容：比较HH:MM:SS时间，注意：用HH*3600+MM*60+SS来比较写sort的比较函数会比较简单
7.下标规划题，内容：查找一串数中最大的子数列，注意：因为数列中可能有0，所以sum一开始要置-1，以及立flg来检测是否全为负数
8.逻辑，内容：做电梯的时间（太简单忽略好了）
9.逻辑，内容：多项式相乘，注意：多项式系数为0的情况，相乘时的最大系数可能为单个多项式输入系数的两倍
10.进制转换，二分法，数据范围，内容：进制转换，注意：确定进制上下界，用二分法来寻找使得数据相等的进制，在寻找的过程中，当数据2计算过程中的值超过数据1的值的时候应该break剪枝，测试点10好像是个坑，加上注释掉区包围的代码才算对，但感觉判定有问题，如果测试用例是1 1 1 10，答案输出应该是2才对吧，加上岂不是10了...不知道是什么奇怪的原因
11.逻辑，内容：找最大输出，注意：用数组实现字符串的选择输出比较酷，这道题的答案和样例的输出不一样却是对的，我也是醉了，我还强行试着四舍五入一下，没事不要作
12.排序，内容：输出一个学生的名次最高的科目（有许多学科和学生），注意：多多个科目使用sort函数，可以用一个flg，来改变数组下标，以此来改变排序所依据的数据，成绩一样并列名次的处理，可以让该学生的名次等于上一个学生的名次，一旦不同，还是用循环的下标确定名次。
13.图，bfs/dfs，图的连通分量的统计，内容：图的一个节点被拆除后剩余多少连通分量，注意：在遍历的最大for循环里，对没访问的节点加个统计值cnt就可以了
14.queue，逻辑，内容：银行排队，注意：只要在17:00前开始办理业务的就能办理完（坑），处理好队列中元素是不是达到capacity的情况，先遍历队列的元素个数，找最小值，如果最小值为capacity，就pop出所有队列中第一个元素最小的值，并把其他的队列值的以一个元素减去该值，在把接受到的顾客push进刚刚pop出的那个队列。
15.素数，进制转换，内容：求一个数在某进制下的逆序数字再转换为10进制是否是素数，注意：0,1不是素数，2是素数，可以用i*i<n来代替i<sqrt(n)。
16.排序，处理输入输出，时间转换，内容：输出不同时段的电话费不同，一群人打了一万个电话，让算钱，注意：这道题大坑啊，其中包括一个如果都是无效输入的话就不打印他的信息。
17.排序，逻辑，内容：又是银行排队，注意：处理好提早到的(用８点减去他们到的时间)，17:00以后到的，直接在循环开始的时候判断然后continue，然后需要一个时间戳，在每个顾客进来的时候与时间戳比较决定是否更新时间戳或者增加waitingtime的综合，或者在队伍全不为0的时候更新(推出processing time里时间最短的那个，并把其他顾客的时间减去该时间，更新时间戳+=processing time)，更新最小的那个时间为当前顾客所需处理时间，如果含0，直接更新为当前顾客所需时间。
18.图，dijkstra，dfs，内容：自行车容量调节，注意：首先用dijkstra算法求最短路径(可能有多条，所以存路径的path数组本身也是个数组，可以用vector<int> path[501]实现)，然后对最短路径进行dfs，并用vector<int>tmppath存路径，每次递归到原点的时候于最少需要携带的自行车和最少需要带回的自行车比较并决定是否更新path。
19.进制，回文，内容：判断一个数是否是在某进制下的回文数字，注意：0
20.树的遍历，bfs，内容：已知树的后序和中序输出建树，然后再层序输出，注意：递归时候的范围。
21.树，bfs/dfs，树的层数，连通分量，内容：判断一个图是不是树，注意：要把每个根节点作为起始节点算一遍，可以判断有多少个连通分量，同时也要记录下每个节点的层数和树的总层数。
22.输入输出，字符串，map<string, set<int>>，内容：处理图书输入和检索，注意：学一下map先= =
23.大数处理，内容：一个数字乘2后的每个数字的个数是否与之前相同，注意：20位及以上的数字就要用char来处理了，long long并不行
24.大数相加，内容：不断讲输入数与输入数的逆序相加并判断是不是回文数，注意：可以用string存,然后用reverse(s.bebgin(), s.end())得到反向的字符串，就可以直接用string的相等运算符比较了，字符串数的相加要熟练，麻痹，我又制造了一堆垃圾代码
25.排序，内容：对各个考场的学生的成绩进行按考场排序和总排序，然后输出
26.排队
27.进制转换，内容：13进制转换
28.排序，内容：按照某个信息排序，注意：不要用cout输出，不然会超时
29.排序，内容：对两个数列排序，注意：不知道为什么long不行改成int就可以了。
30.
31.输入输出
